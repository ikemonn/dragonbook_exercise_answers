# 1.2 (8/16)
- コンパイルは解析と合成部分にわかれている
- 解析 (フロントエンド)
  - 原始プログラムを構成要素に分解し、それらに文法的な構造を与える
  - 記号表と呼ばれるデータ構造に原始プログラムの情報を収集する
- 合成 (バックエンド)
  - 中間表現と記号表中の情報とから目的プログラムを作り出す

- 字句解析 → 構文解析 → 意味解析 → 中間コード生成 → 機械独立なコード最適化 →コード生成 → 機械依存のコード最適化

## 1.2.1 字句解析
- 字句解析器は文字ストリームを読み込んで、トークンを出力する
  - <トークン名, 属性値>
  - トークン名: 構文解析で用いられる抽象的な記号
  - 属性値: トークンに対する記号表中のエントリ

```
position = initial + rate * 60
```

1. positionは1つの字句で、トークン<id, 1>に変換される
  - idは識別子を表す抽象記号
  - 1は記号表中の1番目のエントリ
2. = はトークン<=>に変換される
  - 属性値は不要
3. initialは<id, 2>
4. 60は<60>

```
<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>
```

## 1.2.2 構文解析
- 構文解析器は字句解析器が作り出すトークンの最初の要素を用いて、トークン列がもつ文法構造を明らかにし。それを描いた木構造風の中間表現を作成する

## 1.2.3 意味解析 (8/17)
- 構文木と記号表中の情報を用いて、言語定義に基づいて原始プログラムの意味的一貫性をチェックする
- 重要なのは型検査
  - 各演算子が適切なオペランドを持っているかをチェックする
- JSのように、 `浮動小数点型 + 整数型` を計算しようとすると双方を浮動小数点型にするのも、ここで行われる
  - 強制型変換

## 1.2.4 中間コード生成
- 原始プログラムの構文解析と意味解析が終わると、多くのコンパイラでは明示的に機械語風の中間表現を生成する

## 1.2.5 コード最適化
- 機械独立なコード最適化フェーズでは、より良い(効率的な、速い等)コードを生成する

## 1.2.6 コード生成
- 原始プログラムの中間表現を入力として、それを目的言語に変換する
- 目的言語が機械コードである場合、プログラムで使用している各変数にはレジスタかメモリが与えられる

## 1.2.7 記号表の管理
- 記号表は一種のデータ構造
  - 変数名毎に1つの構造体を持つ
  - 変数名が持つ各属性がその各フィールドを構成する

## 1.2.8 フェーズからパスへのまとめ方
- パス = 入力ファイルを読み込んで出力ファイルを書き出す作業単位
- 幾つかのフェーズにおける処理を１つにまとめることがある
  - 字句解析、構文解析、意味解析、中間コード生成のフロントエンドフェーズは1つのパスにまとめられる
- バックエンドとフロントエンドが分離できるので、原始言語と目的言語に合わせて組み合わせることができる

## コンパイラ作成ツール
